
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.ts"
import { type PrismaClient } from "./class.ts"

export type * from '../models.ts'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.4.1
 * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.4.1",
  engine: "55ae170b1ced7fc6ed07a15f110549408c501bb3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Electronic: 'Electronic',
  Electronic_Books: 'Electronic_Books',
  Entry_Status: 'Entry_Status',
  Fiscal_Support: 'Fiscal_Support',
  Library: 'Library',
  LibraryYear_ListAV: 'LibraryYear_ListAV',
  LibraryYear_ListEBook: 'LibraryYear_ListEBook',
  LibraryYear_ListEJournal: 'LibraryYear_ListEJournal',
  List_AV: 'List_AV',
  List_AV_Counts: 'List_AV_Counts',
  List_AV_Language: 'List_AV_Language',
  ListCustomOtherHoldings: 'ListCustomOtherHoldings',
  List_EBook: 'List_EBook',
  List_EBook_Counts: 'List_EBook_Counts',
  List_EBook_Language: 'List_EBook_Language',
  List_EJournal: 'List_EJournal',
  List_EJournal_Counts: 'List_EJournal_Counts',
  List_EJournal_Language: 'List_EJournal_Language',
  Monographic_Acquisitions: 'Monographic_Acquisitions',
  Other_Holdings: 'Other_Holdings',
  Personnel_Support: 'Personnel_Support',
  Public_Services: 'Public_Services',
  Exclude_Year: 'Exclude_Year',
  Reflibrarytype: 'Reflibrarytype',
  Reflibraryregion: 'Reflibraryregion',
  Language: 'Language',
  Library_Year: 'Library_Year',
  User: 'User',
  Session: 'Session',
  VerificationToken: 'VerificationToken',
  AuditLog: 'AuditLog',
  User_Library: 'User_Library',
  Role: 'Role',
  Users_Roles: 'Users_Roles',
  ScheduledEvent: 'ScheduledEvent',
  Serials: 'Serials',
  SurveySession: 'SurveySession',
  Unprocessed_Backlog_Materials: 'Unprocessed_Backlog_Materials',
  Volume_Holdings: 'Volume_Holdings'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "electronic" | "electronic_Books" | "entry_Status" | "fiscal_Support" | "library" | "libraryYear_ListAV" | "libraryYear_ListEBook" | "libraryYear_ListEJournal" | "list_AV" | "list_AV_Counts" | "list_AV_Language" | "listCustomOtherHoldings" | "list_EBook" | "list_EBook_Counts" | "list_EBook_Language" | "list_EJournal" | "list_EJournal_Counts" | "list_EJournal_Language" | "monographic_Acquisitions" | "other_Holdings" | "personnel_Support" | "public_Services" | "exclude_Year" | "reflibrarytype" | "reflibraryregion" | "language" | "library_Year" | "user" | "session" | "verificationToken" | "auditLog" | "user_Library" | "role" | "users_Roles" | "scheduledEvent" | "serials" | "surveySession" | "unprocessed_Backlog_Materials" | "volume_Holdings"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Electronic: {
      payload: Prisma.$ElectronicPayload<ExtArgs>
      fields: Prisma.ElectronicFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ElectronicFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ElectronicFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>
        }
        findFirst: {
          args: Prisma.ElectronicFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ElectronicFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>
        }
        findMany: {
          args: Prisma.ElectronicFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>[]
        }
        create: {
          args: Prisma.ElectronicCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>
        }
        createMany: {
          args: Prisma.ElectronicCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ElectronicCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>[]
        }
        delete: {
          args: Prisma.ElectronicDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>
        }
        update: {
          args: Prisma.ElectronicUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>
        }
        deleteMany: {
          args: Prisma.ElectronicDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ElectronicUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ElectronicUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>[]
        }
        upsert: {
          args: Prisma.ElectronicUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ElectronicPayload>
        }
        aggregate: {
          args: Prisma.ElectronicAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateElectronic>
        }
        groupBy: {
          args: Prisma.ElectronicGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ElectronicGroupByOutputType>[]
        }
        count: {
          args: Prisma.ElectronicCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ElectronicCountAggregateOutputType> | number
        }
      }
    }
    Electronic_Books: {
      payload: Prisma.$Electronic_BooksPayload<ExtArgs>
      fields: Prisma.Electronic_BooksFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Electronic_BooksFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Electronic_BooksFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>
        }
        findFirst: {
          args: Prisma.Electronic_BooksFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Electronic_BooksFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>
        }
        findMany: {
          args: Prisma.Electronic_BooksFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>[]
        }
        create: {
          args: Prisma.Electronic_BooksCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>
        }
        createMany: {
          args: Prisma.Electronic_BooksCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Electronic_BooksCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>[]
        }
        delete: {
          args: Prisma.Electronic_BooksDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>
        }
        update: {
          args: Prisma.Electronic_BooksUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>
        }
        deleteMany: {
          args: Prisma.Electronic_BooksDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Electronic_BooksUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Electronic_BooksUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>[]
        }
        upsert: {
          args: Prisma.Electronic_BooksUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Electronic_BooksPayload>
        }
        aggregate: {
          args: Prisma.Electronic_BooksAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateElectronic_Books>
        }
        groupBy: {
          args: Prisma.Electronic_BooksGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Electronic_BooksGroupByOutputType>[]
        }
        count: {
          args: Prisma.Electronic_BooksCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Electronic_BooksCountAggregateOutputType> | number
        }
      }
    }
    Entry_Status: {
      payload: Prisma.$Entry_StatusPayload<ExtArgs>
      fields: Prisma.Entry_StatusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Entry_StatusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Entry_StatusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>
        }
        findFirst: {
          args: Prisma.Entry_StatusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Entry_StatusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>
        }
        findMany: {
          args: Prisma.Entry_StatusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>[]
        }
        create: {
          args: Prisma.Entry_StatusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>
        }
        createMany: {
          args: Prisma.Entry_StatusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Entry_StatusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>[]
        }
        delete: {
          args: Prisma.Entry_StatusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>
        }
        update: {
          args: Prisma.Entry_StatusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>
        }
        deleteMany: {
          args: Prisma.Entry_StatusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Entry_StatusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Entry_StatusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>[]
        }
        upsert: {
          args: Prisma.Entry_StatusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Entry_StatusPayload>
        }
        aggregate: {
          args: Prisma.Entry_StatusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEntry_Status>
        }
        groupBy: {
          args: Prisma.Entry_StatusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Entry_StatusGroupByOutputType>[]
        }
        count: {
          args: Prisma.Entry_StatusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Entry_StatusCountAggregateOutputType> | number
        }
      }
    }
    Fiscal_Support: {
      payload: Prisma.$Fiscal_SupportPayload<ExtArgs>
      fields: Prisma.Fiscal_SupportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Fiscal_SupportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Fiscal_SupportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>
        }
        findFirst: {
          args: Prisma.Fiscal_SupportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Fiscal_SupportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>
        }
        findMany: {
          args: Prisma.Fiscal_SupportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>[]
        }
        create: {
          args: Prisma.Fiscal_SupportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>
        }
        createMany: {
          args: Prisma.Fiscal_SupportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Fiscal_SupportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>[]
        }
        delete: {
          args: Prisma.Fiscal_SupportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>
        }
        update: {
          args: Prisma.Fiscal_SupportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>
        }
        deleteMany: {
          args: Prisma.Fiscal_SupportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Fiscal_SupportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Fiscal_SupportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>[]
        }
        upsert: {
          args: Prisma.Fiscal_SupportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Fiscal_SupportPayload>
        }
        aggregate: {
          args: Prisma.Fiscal_SupportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFiscal_Support>
        }
        groupBy: {
          args: Prisma.Fiscal_SupportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Fiscal_SupportGroupByOutputType>[]
        }
        count: {
          args: Prisma.Fiscal_SupportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Fiscal_SupportCountAggregateOutputType> | number
        }
      }
    }
    Library: {
      payload: Prisma.$LibraryPayload<ExtArgs>
      fields: Prisma.LibraryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LibraryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LibraryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>
        }
        findFirst: {
          args: Prisma.LibraryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LibraryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>
        }
        findMany: {
          args: Prisma.LibraryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>[]
        }
        create: {
          args: Prisma.LibraryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>
        }
        createMany: {
          args: Prisma.LibraryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LibraryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>[]
        }
        delete: {
          args: Prisma.LibraryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>
        }
        update: {
          args: Prisma.LibraryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>
        }
        deleteMany: {
          args: Prisma.LibraryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LibraryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LibraryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>[]
        }
        upsert: {
          args: Prisma.LibraryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryPayload>
        }
        aggregate: {
          args: Prisma.LibraryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLibrary>
        }
        groupBy: {
          args: Prisma.LibraryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryGroupByOutputType>[]
        }
        count: {
          args: Prisma.LibraryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryCountAggregateOutputType> | number
        }
      }
    }
    LibraryYear_ListAV: {
      payload: Prisma.$LibraryYear_ListAVPayload<ExtArgs>
      fields: Prisma.LibraryYear_ListAVFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LibraryYear_ListAVFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LibraryYear_ListAVFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>
        }
        findFirst: {
          args: Prisma.LibraryYear_ListAVFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LibraryYear_ListAVFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>
        }
        findMany: {
          args: Prisma.LibraryYear_ListAVFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>[]
        }
        create: {
          args: Prisma.LibraryYear_ListAVCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>
        }
        createMany: {
          args: Prisma.LibraryYear_ListAVCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LibraryYear_ListAVCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>[]
        }
        delete: {
          args: Prisma.LibraryYear_ListAVDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>
        }
        update: {
          args: Prisma.LibraryYear_ListAVUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>
        }
        deleteMany: {
          args: Prisma.LibraryYear_ListAVDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LibraryYear_ListAVUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LibraryYear_ListAVUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>[]
        }
        upsert: {
          args: Prisma.LibraryYear_ListAVUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListAVPayload>
        }
        aggregate: {
          args: Prisma.LibraryYear_ListAVAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLibraryYear_ListAV>
        }
        groupBy: {
          args: Prisma.LibraryYear_ListAVGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryYear_ListAVGroupByOutputType>[]
        }
        count: {
          args: Prisma.LibraryYear_ListAVCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryYear_ListAVCountAggregateOutputType> | number
        }
      }
    }
    LibraryYear_ListEBook: {
      payload: Prisma.$LibraryYear_ListEBookPayload<ExtArgs>
      fields: Prisma.LibraryYear_ListEBookFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LibraryYear_ListEBookFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LibraryYear_ListEBookFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>
        }
        findFirst: {
          args: Prisma.LibraryYear_ListEBookFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LibraryYear_ListEBookFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>
        }
        findMany: {
          args: Prisma.LibraryYear_ListEBookFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>[]
        }
        create: {
          args: Prisma.LibraryYear_ListEBookCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>
        }
        createMany: {
          args: Prisma.LibraryYear_ListEBookCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LibraryYear_ListEBookCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>[]
        }
        delete: {
          args: Prisma.LibraryYear_ListEBookDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>
        }
        update: {
          args: Prisma.LibraryYear_ListEBookUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>
        }
        deleteMany: {
          args: Prisma.LibraryYear_ListEBookDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LibraryYear_ListEBookUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LibraryYear_ListEBookUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>[]
        }
        upsert: {
          args: Prisma.LibraryYear_ListEBookUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEBookPayload>
        }
        aggregate: {
          args: Prisma.LibraryYear_ListEBookAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLibraryYear_ListEBook>
        }
        groupBy: {
          args: Prisma.LibraryYear_ListEBookGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryYear_ListEBookGroupByOutputType>[]
        }
        count: {
          args: Prisma.LibraryYear_ListEBookCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryYear_ListEBookCountAggregateOutputType> | number
        }
      }
    }
    LibraryYear_ListEJournal: {
      payload: Prisma.$LibraryYear_ListEJournalPayload<ExtArgs>
      fields: Prisma.LibraryYear_ListEJournalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LibraryYear_ListEJournalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LibraryYear_ListEJournalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>
        }
        findFirst: {
          args: Prisma.LibraryYear_ListEJournalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LibraryYear_ListEJournalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>
        }
        findMany: {
          args: Prisma.LibraryYear_ListEJournalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>[]
        }
        create: {
          args: Prisma.LibraryYear_ListEJournalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>
        }
        createMany: {
          args: Prisma.LibraryYear_ListEJournalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LibraryYear_ListEJournalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>[]
        }
        delete: {
          args: Prisma.LibraryYear_ListEJournalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>
        }
        update: {
          args: Prisma.LibraryYear_ListEJournalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>
        }
        deleteMany: {
          args: Prisma.LibraryYear_ListEJournalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LibraryYear_ListEJournalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LibraryYear_ListEJournalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>[]
        }
        upsert: {
          args: Prisma.LibraryYear_ListEJournalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LibraryYear_ListEJournalPayload>
        }
        aggregate: {
          args: Prisma.LibraryYear_ListEJournalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLibraryYear_ListEJournal>
        }
        groupBy: {
          args: Prisma.LibraryYear_ListEJournalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryYear_ListEJournalGroupByOutputType>[]
        }
        count: {
          args: Prisma.LibraryYear_ListEJournalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LibraryYear_ListEJournalCountAggregateOutputType> | number
        }
      }
    }
    List_AV: {
      payload: Prisma.$List_AVPayload<ExtArgs>
      fields: Prisma.List_AVFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_AVFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_AVFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>
        }
        findFirst: {
          args: Prisma.List_AVFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_AVFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>
        }
        findMany: {
          args: Prisma.List_AVFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>[]
        }
        create: {
          args: Prisma.List_AVCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>
        }
        createMany: {
          args: Prisma.List_AVCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_AVCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>[]
        }
        delete: {
          args: Prisma.List_AVDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>
        }
        update: {
          args: Prisma.List_AVUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>
        }
        deleteMany: {
          args: Prisma.List_AVDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_AVUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_AVUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>[]
        }
        upsert: {
          args: Prisma.List_AVUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AVPayload>
        }
        aggregate: {
          args: Prisma.List_AVAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_AV>
        }
        groupBy: {
          args: Prisma.List_AVGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_AVGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_AVCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_AVCountAggregateOutputType> | number
        }
      }
    }
    List_AV_Counts: {
      payload: Prisma.$List_AV_CountsPayload<ExtArgs>
      fields: Prisma.List_AV_CountsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_AV_CountsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_AV_CountsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>
        }
        findFirst: {
          args: Prisma.List_AV_CountsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_AV_CountsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>
        }
        findMany: {
          args: Prisma.List_AV_CountsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>[]
        }
        create: {
          args: Prisma.List_AV_CountsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>
        }
        createMany: {
          args: Prisma.List_AV_CountsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_AV_CountsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>[]
        }
        delete: {
          args: Prisma.List_AV_CountsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>
        }
        update: {
          args: Prisma.List_AV_CountsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>
        }
        deleteMany: {
          args: Prisma.List_AV_CountsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_AV_CountsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_AV_CountsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>[]
        }
        upsert: {
          args: Prisma.List_AV_CountsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_CountsPayload>
        }
        aggregate: {
          args: Prisma.List_AV_CountsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_AV_Counts>
        }
        groupBy: {
          args: Prisma.List_AV_CountsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_AV_CountsGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_AV_CountsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_AV_CountsCountAggregateOutputType> | number
        }
      }
    }
    List_AV_Language: {
      payload: Prisma.$List_AV_LanguagePayload<ExtArgs>
      fields: Prisma.List_AV_LanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_AV_LanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_AV_LanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>
        }
        findFirst: {
          args: Prisma.List_AV_LanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_AV_LanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>
        }
        findMany: {
          args: Prisma.List_AV_LanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>[]
        }
        create: {
          args: Prisma.List_AV_LanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>
        }
        createMany: {
          args: Prisma.List_AV_LanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_AV_LanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>[]
        }
        delete: {
          args: Prisma.List_AV_LanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>
        }
        update: {
          args: Prisma.List_AV_LanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>
        }
        deleteMany: {
          args: Prisma.List_AV_LanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_AV_LanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_AV_LanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>[]
        }
        upsert: {
          args: Prisma.List_AV_LanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_AV_LanguagePayload>
        }
        aggregate: {
          args: Prisma.List_AV_LanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_AV_Language>
        }
        groupBy: {
          args: Prisma.List_AV_LanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_AV_LanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_AV_LanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_AV_LanguageCountAggregateOutputType> | number
        }
      }
    }
    ListCustomOtherHoldings: {
      payload: Prisma.$ListCustomOtherHoldingsPayload<ExtArgs>
      fields: Prisma.ListCustomOtherHoldingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ListCustomOtherHoldingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ListCustomOtherHoldingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>
        }
        findFirst: {
          args: Prisma.ListCustomOtherHoldingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ListCustomOtherHoldingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>
        }
        findMany: {
          args: Prisma.ListCustomOtherHoldingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>[]
        }
        create: {
          args: Prisma.ListCustomOtherHoldingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>
        }
        createMany: {
          args: Prisma.ListCustomOtherHoldingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ListCustomOtherHoldingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>[]
        }
        delete: {
          args: Prisma.ListCustomOtherHoldingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>
        }
        update: {
          args: Prisma.ListCustomOtherHoldingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>
        }
        deleteMany: {
          args: Prisma.ListCustomOtherHoldingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ListCustomOtherHoldingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ListCustomOtherHoldingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>[]
        }
        upsert: {
          args: Prisma.ListCustomOtherHoldingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListCustomOtherHoldingsPayload>
        }
        aggregate: {
          args: Prisma.ListCustomOtherHoldingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateListCustomOtherHoldings>
        }
        groupBy: {
          args: Prisma.ListCustomOtherHoldingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ListCustomOtherHoldingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ListCustomOtherHoldingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ListCustomOtherHoldingsCountAggregateOutputType> | number
        }
      }
    }
    List_EBook: {
      payload: Prisma.$List_EBookPayload<ExtArgs>
      fields: Prisma.List_EBookFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_EBookFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_EBookFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>
        }
        findFirst: {
          args: Prisma.List_EBookFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_EBookFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>
        }
        findMany: {
          args: Prisma.List_EBookFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>[]
        }
        create: {
          args: Prisma.List_EBookCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>
        }
        createMany: {
          args: Prisma.List_EBookCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_EBookCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>[]
        }
        delete: {
          args: Prisma.List_EBookDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>
        }
        update: {
          args: Prisma.List_EBookUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>
        }
        deleteMany: {
          args: Prisma.List_EBookDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_EBookUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_EBookUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>[]
        }
        upsert: {
          args: Prisma.List_EBookUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBookPayload>
        }
        aggregate: {
          args: Prisma.List_EBookAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_EBook>
        }
        groupBy: {
          args: Prisma.List_EBookGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EBookGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_EBookCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EBookCountAggregateOutputType> | number
        }
      }
    }
    List_EBook_Counts: {
      payload: Prisma.$List_EBook_CountsPayload<ExtArgs>
      fields: Prisma.List_EBook_CountsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_EBook_CountsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_EBook_CountsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>
        }
        findFirst: {
          args: Prisma.List_EBook_CountsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_EBook_CountsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>
        }
        findMany: {
          args: Prisma.List_EBook_CountsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>[]
        }
        create: {
          args: Prisma.List_EBook_CountsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>
        }
        createMany: {
          args: Prisma.List_EBook_CountsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_EBook_CountsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>[]
        }
        delete: {
          args: Prisma.List_EBook_CountsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>
        }
        update: {
          args: Prisma.List_EBook_CountsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>
        }
        deleteMany: {
          args: Prisma.List_EBook_CountsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_EBook_CountsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_EBook_CountsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>[]
        }
        upsert: {
          args: Prisma.List_EBook_CountsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_CountsPayload>
        }
        aggregate: {
          args: Prisma.List_EBook_CountsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_EBook_Counts>
        }
        groupBy: {
          args: Prisma.List_EBook_CountsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EBook_CountsGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_EBook_CountsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EBook_CountsCountAggregateOutputType> | number
        }
      }
    }
    List_EBook_Language: {
      payload: Prisma.$List_EBook_LanguagePayload<ExtArgs>
      fields: Prisma.List_EBook_LanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_EBook_LanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_EBook_LanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>
        }
        findFirst: {
          args: Prisma.List_EBook_LanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_EBook_LanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>
        }
        findMany: {
          args: Prisma.List_EBook_LanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>[]
        }
        create: {
          args: Prisma.List_EBook_LanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>
        }
        createMany: {
          args: Prisma.List_EBook_LanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_EBook_LanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>[]
        }
        delete: {
          args: Prisma.List_EBook_LanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>
        }
        update: {
          args: Prisma.List_EBook_LanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>
        }
        deleteMany: {
          args: Prisma.List_EBook_LanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_EBook_LanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_EBook_LanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>[]
        }
        upsert: {
          args: Prisma.List_EBook_LanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EBook_LanguagePayload>
        }
        aggregate: {
          args: Prisma.List_EBook_LanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_EBook_Language>
        }
        groupBy: {
          args: Prisma.List_EBook_LanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EBook_LanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_EBook_LanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EBook_LanguageCountAggregateOutputType> | number
        }
      }
    }
    List_EJournal: {
      payload: Prisma.$List_EJournalPayload<ExtArgs>
      fields: Prisma.List_EJournalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_EJournalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_EJournalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>
        }
        findFirst: {
          args: Prisma.List_EJournalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_EJournalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>
        }
        findMany: {
          args: Prisma.List_EJournalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>[]
        }
        create: {
          args: Prisma.List_EJournalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>
        }
        createMany: {
          args: Prisma.List_EJournalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_EJournalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>[]
        }
        delete: {
          args: Prisma.List_EJournalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>
        }
        update: {
          args: Prisma.List_EJournalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>
        }
        deleteMany: {
          args: Prisma.List_EJournalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_EJournalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_EJournalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>[]
        }
        upsert: {
          args: Prisma.List_EJournalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournalPayload>
        }
        aggregate: {
          args: Prisma.List_EJournalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_EJournal>
        }
        groupBy: {
          args: Prisma.List_EJournalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EJournalGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_EJournalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EJournalCountAggregateOutputType> | number
        }
      }
    }
    List_EJournal_Counts: {
      payload: Prisma.$List_EJournal_CountsPayload<ExtArgs>
      fields: Prisma.List_EJournal_CountsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_EJournal_CountsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_EJournal_CountsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>
        }
        findFirst: {
          args: Prisma.List_EJournal_CountsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_EJournal_CountsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>
        }
        findMany: {
          args: Prisma.List_EJournal_CountsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>[]
        }
        create: {
          args: Prisma.List_EJournal_CountsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>
        }
        createMany: {
          args: Prisma.List_EJournal_CountsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_EJournal_CountsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>[]
        }
        delete: {
          args: Prisma.List_EJournal_CountsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>
        }
        update: {
          args: Prisma.List_EJournal_CountsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>
        }
        deleteMany: {
          args: Prisma.List_EJournal_CountsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_EJournal_CountsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_EJournal_CountsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>[]
        }
        upsert: {
          args: Prisma.List_EJournal_CountsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_CountsPayload>
        }
        aggregate: {
          args: Prisma.List_EJournal_CountsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_EJournal_Counts>
        }
        groupBy: {
          args: Prisma.List_EJournal_CountsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EJournal_CountsGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_EJournal_CountsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EJournal_CountsCountAggregateOutputType> | number
        }
      }
    }
    List_EJournal_Language: {
      payload: Prisma.$List_EJournal_LanguagePayload<ExtArgs>
      fields: Prisma.List_EJournal_LanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.List_EJournal_LanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.List_EJournal_LanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>
        }
        findFirst: {
          args: Prisma.List_EJournal_LanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.List_EJournal_LanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>
        }
        findMany: {
          args: Prisma.List_EJournal_LanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>[]
        }
        create: {
          args: Prisma.List_EJournal_LanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>
        }
        createMany: {
          args: Prisma.List_EJournal_LanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.List_EJournal_LanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>[]
        }
        delete: {
          args: Prisma.List_EJournal_LanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>
        }
        update: {
          args: Prisma.List_EJournal_LanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>
        }
        deleteMany: {
          args: Prisma.List_EJournal_LanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.List_EJournal_LanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.List_EJournal_LanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>[]
        }
        upsert: {
          args: Prisma.List_EJournal_LanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$List_EJournal_LanguagePayload>
        }
        aggregate: {
          args: Prisma.List_EJournal_LanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateList_EJournal_Language>
        }
        groupBy: {
          args: Prisma.List_EJournal_LanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EJournal_LanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.List_EJournal_LanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.List_EJournal_LanguageCountAggregateOutputType> | number
        }
      }
    }
    Monographic_Acquisitions: {
      payload: Prisma.$Monographic_AcquisitionsPayload<ExtArgs>
      fields: Prisma.Monographic_AcquisitionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Monographic_AcquisitionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Monographic_AcquisitionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>
        }
        findFirst: {
          args: Prisma.Monographic_AcquisitionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Monographic_AcquisitionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>
        }
        findMany: {
          args: Prisma.Monographic_AcquisitionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>[]
        }
        create: {
          args: Prisma.Monographic_AcquisitionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>
        }
        createMany: {
          args: Prisma.Monographic_AcquisitionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Monographic_AcquisitionsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>[]
        }
        delete: {
          args: Prisma.Monographic_AcquisitionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>
        }
        update: {
          args: Prisma.Monographic_AcquisitionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>
        }
        deleteMany: {
          args: Prisma.Monographic_AcquisitionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Monographic_AcquisitionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Monographic_AcquisitionsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>[]
        }
        upsert: {
          args: Prisma.Monographic_AcquisitionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Monographic_AcquisitionsPayload>
        }
        aggregate: {
          args: Prisma.Monographic_AcquisitionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMonographic_Acquisitions>
        }
        groupBy: {
          args: Prisma.Monographic_AcquisitionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Monographic_AcquisitionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.Monographic_AcquisitionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Monographic_AcquisitionsCountAggregateOutputType> | number
        }
      }
    }
    Other_Holdings: {
      payload: Prisma.$Other_HoldingsPayload<ExtArgs>
      fields: Prisma.Other_HoldingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Other_HoldingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Other_HoldingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>
        }
        findFirst: {
          args: Prisma.Other_HoldingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Other_HoldingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>
        }
        findMany: {
          args: Prisma.Other_HoldingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>[]
        }
        create: {
          args: Prisma.Other_HoldingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>
        }
        createMany: {
          args: Prisma.Other_HoldingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Other_HoldingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>[]
        }
        delete: {
          args: Prisma.Other_HoldingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>
        }
        update: {
          args: Prisma.Other_HoldingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>
        }
        deleteMany: {
          args: Prisma.Other_HoldingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Other_HoldingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Other_HoldingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>[]
        }
        upsert: {
          args: Prisma.Other_HoldingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Other_HoldingsPayload>
        }
        aggregate: {
          args: Prisma.Other_HoldingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOther_Holdings>
        }
        groupBy: {
          args: Prisma.Other_HoldingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Other_HoldingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.Other_HoldingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Other_HoldingsCountAggregateOutputType> | number
        }
      }
    }
    Personnel_Support: {
      payload: Prisma.$Personnel_SupportPayload<ExtArgs>
      fields: Prisma.Personnel_SupportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Personnel_SupportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Personnel_SupportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>
        }
        findFirst: {
          args: Prisma.Personnel_SupportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Personnel_SupportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>
        }
        findMany: {
          args: Prisma.Personnel_SupportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>[]
        }
        create: {
          args: Prisma.Personnel_SupportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>
        }
        createMany: {
          args: Prisma.Personnel_SupportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Personnel_SupportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>[]
        }
        delete: {
          args: Prisma.Personnel_SupportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>
        }
        update: {
          args: Prisma.Personnel_SupportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>
        }
        deleteMany: {
          args: Prisma.Personnel_SupportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Personnel_SupportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Personnel_SupportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>[]
        }
        upsert: {
          args: Prisma.Personnel_SupportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Personnel_SupportPayload>
        }
        aggregate: {
          args: Prisma.Personnel_SupportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePersonnel_Support>
        }
        groupBy: {
          args: Prisma.Personnel_SupportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Personnel_SupportGroupByOutputType>[]
        }
        count: {
          args: Prisma.Personnel_SupportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Personnel_SupportCountAggregateOutputType> | number
        }
      }
    }
    Public_Services: {
      payload: Prisma.$Public_ServicesPayload<ExtArgs>
      fields: Prisma.Public_ServicesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Public_ServicesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Public_ServicesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>
        }
        findFirst: {
          args: Prisma.Public_ServicesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Public_ServicesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>
        }
        findMany: {
          args: Prisma.Public_ServicesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>[]
        }
        create: {
          args: Prisma.Public_ServicesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>
        }
        createMany: {
          args: Prisma.Public_ServicesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Public_ServicesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>[]
        }
        delete: {
          args: Prisma.Public_ServicesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>
        }
        update: {
          args: Prisma.Public_ServicesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>
        }
        deleteMany: {
          args: Prisma.Public_ServicesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Public_ServicesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Public_ServicesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>[]
        }
        upsert: {
          args: Prisma.Public_ServicesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Public_ServicesPayload>
        }
        aggregate: {
          args: Prisma.Public_ServicesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePublic_Services>
        }
        groupBy: {
          args: Prisma.Public_ServicesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Public_ServicesGroupByOutputType>[]
        }
        count: {
          args: Prisma.Public_ServicesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Public_ServicesCountAggregateOutputType> | number
        }
      }
    }
    Exclude_Year: {
      payload: Prisma.$Exclude_YearPayload<ExtArgs>
      fields: Prisma.Exclude_YearFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Exclude_YearFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Exclude_YearFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>
        }
        findFirst: {
          args: Prisma.Exclude_YearFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Exclude_YearFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>
        }
        findMany: {
          args: Prisma.Exclude_YearFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>[]
        }
        create: {
          args: Prisma.Exclude_YearCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>
        }
        createMany: {
          args: Prisma.Exclude_YearCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Exclude_YearCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>[]
        }
        delete: {
          args: Prisma.Exclude_YearDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>
        }
        update: {
          args: Prisma.Exclude_YearUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>
        }
        deleteMany: {
          args: Prisma.Exclude_YearDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Exclude_YearUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Exclude_YearUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>[]
        }
        upsert: {
          args: Prisma.Exclude_YearUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Exclude_YearPayload>
        }
        aggregate: {
          args: Prisma.Exclude_YearAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExclude_Year>
        }
        groupBy: {
          args: Prisma.Exclude_YearGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Exclude_YearGroupByOutputType>[]
        }
        count: {
          args: Prisma.Exclude_YearCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Exclude_YearCountAggregateOutputType> | number
        }
      }
    }
    Reflibrarytype: {
      payload: Prisma.$ReflibrarytypePayload<ExtArgs>
      fields: Prisma.ReflibrarytypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReflibrarytypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReflibrarytypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>
        }
        findFirst: {
          args: Prisma.ReflibrarytypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReflibrarytypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>
        }
        findMany: {
          args: Prisma.ReflibrarytypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>[]
        }
        create: {
          args: Prisma.ReflibrarytypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>
        }
        createMany: {
          args: Prisma.ReflibrarytypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReflibrarytypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>[]
        }
        delete: {
          args: Prisma.ReflibrarytypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>
        }
        update: {
          args: Prisma.ReflibrarytypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>
        }
        deleteMany: {
          args: Prisma.ReflibrarytypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReflibrarytypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReflibrarytypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>[]
        }
        upsert: {
          args: Prisma.ReflibrarytypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibrarytypePayload>
        }
        aggregate: {
          args: Prisma.ReflibrarytypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReflibrarytype>
        }
        groupBy: {
          args: Prisma.ReflibrarytypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReflibrarytypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReflibrarytypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReflibrarytypeCountAggregateOutputType> | number
        }
      }
    }
    Reflibraryregion: {
      payload: Prisma.$ReflibraryregionPayload<ExtArgs>
      fields: Prisma.ReflibraryregionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReflibraryregionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReflibraryregionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>
        }
        findFirst: {
          args: Prisma.ReflibraryregionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReflibraryregionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>
        }
        findMany: {
          args: Prisma.ReflibraryregionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>[]
        }
        create: {
          args: Prisma.ReflibraryregionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>
        }
        createMany: {
          args: Prisma.ReflibraryregionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReflibraryregionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>[]
        }
        delete: {
          args: Prisma.ReflibraryregionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>
        }
        update: {
          args: Prisma.ReflibraryregionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>
        }
        deleteMany: {
          args: Prisma.ReflibraryregionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReflibraryregionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReflibraryregionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>[]
        }
        upsert: {
          args: Prisma.ReflibraryregionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReflibraryregionPayload>
        }
        aggregate: {
          args: Prisma.ReflibraryregionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReflibraryregion>
        }
        groupBy: {
          args: Prisma.ReflibraryregionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReflibraryregionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReflibraryregionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReflibraryregionCountAggregateOutputType> | number
        }
      }
    }
    Language: {
      payload: Prisma.$LanguagePayload<ExtArgs>
      fields: Prisma.LanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        findFirst: {
          args: Prisma.LanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        findMany: {
          args: Prisma.LanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>[]
        }
        create: {
          args: Prisma.LanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        createMany: {
          args: Prisma.LanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>[]
        }
        delete: {
          args: Prisma.LanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        update: {
          args: Prisma.LanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        deleteMany: {
          args: Prisma.LanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>[]
        }
        upsert: {
          args: Prisma.LanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        aggregate: {
          args: Prisma.LanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLanguage>
        }
        groupBy: {
          args: Prisma.LanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.LanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LanguageCountAggregateOutputType> | number
        }
      }
    }
    Library_Year: {
      payload: Prisma.$Library_YearPayload<ExtArgs>
      fields: Prisma.Library_YearFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Library_YearFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Library_YearFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>
        }
        findFirst: {
          args: Prisma.Library_YearFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Library_YearFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>
        }
        findMany: {
          args: Prisma.Library_YearFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>[]
        }
        create: {
          args: Prisma.Library_YearCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>
        }
        createMany: {
          args: Prisma.Library_YearCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Library_YearCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>[]
        }
        delete: {
          args: Prisma.Library_YearDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>
        }
        update: {
          args: Prisma.Library_YearUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>
        }
        deleteMany: {
          args: Prisma.Library_YearDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Library_YearUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Library_YearUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>[]
        }
        upsert: {
          args: Prisma.Library_YearUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Library_YearPayload>
        }
        aggregate: {
          args: Prisma.Library_YearAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLibrary_Year>
        }
        groupBy: {
          args: Prisma.Library_YearGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Library_YearGroupByOutputType>[]
        }
        count: {
          args: Prisma.Library_YearCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Library_YearCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    VerificationToken: {
      payload: Prisma.$VerificationTokenPayload<ExtArgs>
      fields: Prisma.VerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findMany: {
          args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        create: {
          args: Prisma.VerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        createMany: {
          args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        delete: {
          args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        update: {
          args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        upsert: {
          args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationToken>
        }
        groupBy: {
          args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    User_Library: {
      payload: Prisma.$User_LibraryPayload<ExtArgs>
      fields: Prisma.User_LibraryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.User_LibraryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.User_LibraryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>
        }
        findFirst: {
          args: Prisma.User_LibraryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.User_LibraryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>
        }
        findMany: {
          args: Prisma.User_LibraryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>[]
        }
        create: {
          args: Prisma.User_LibraryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>
        }
        createMany: {
          args: Prisma.User_LibraryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.User_LibraryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>[]
        }
        delete: {
          args: Prisma.User_LibraryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>
        }
        update: {
          args: Prisma.User_LibraryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>
        }
        deleteMany: {
          args: Prisma.User_LibraryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.User_LibraryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.User_LibraryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>[]
        }
        upsert: {
          args: Prisma.User_LibraryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$User_LibraryPayload>
        }
        aggregate: {
          args: Prisma.User_LibraryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser_Library>
        }
        groupBy: {
          args: Prisma.User_LibraryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_LibraryGroupByOutputType>[]
        }
        count: {
          args: Prisma.User_LibraryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_LibraryCountAggregateOutputType> | number
        }
      }
    }
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>
      fields: Prisma.RoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    Users_Roles: {
      payload: Prisma.$Users_RolesPayload<ExtArgs>
      fields: Prisma.Users_RolesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Users_RolesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Users_RolesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>
        }
        findFirst: {
          args: Prisma.Users_RolesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Users_RolesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>
        }
        findMany: {
          args: Prisma.Users_RolesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>[]
        }
        create: {
          args: Prisma.Users_RolesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>
        }
        createMany: {
          args: Prisma.Users_RolesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Users_RolesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>[]
        }
        delete: {
          args: Prisma.Users_RolesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>
        }
        update: {
          args: Prisma.Users_RolesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>
        }
        deleteMany: {
          args: Prisma.Users_RolesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Users_RolesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Users_RolesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>[]
        }
        upsert: {
          args: Prisma.Users_RolesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Users_RolesPayload>
        }
        aggregate: {
          args: Prisma.Users_RolesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUsers_Roles>
        }
        groupBy: {
          args: Prisma.Users_RolesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Users_RolesGroupByOutputType>[]
        }
        count: {
          args: Prisma.Users_RolesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Users_RolesCountAggregateOutputType> | number
        }
      }
    }
    ScheduledEvent: {
      payload: Prisma.$ScheduledEventPayload<ExtArgs>
      fields: Prisma.ScheduledEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScheduledEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScheduledEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>
        }
        findFirst: {
          args: Prisma.ScheduledEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScheduledEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>
        }
        findMany: {
          args: Prisma.ScheduledEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>[]
        }
        create: {
          args: Prisma.ScheduledEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>
        }
        createMany: {
          args: Prisma.ScheduledEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScheduledEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>[]
        }
        delete: {
          args: Prisma.ScheduledEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>
        }
        update: {
          args: Prisma.ScheduledEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>
        }
        deleteMany: {
          args: Prisma.ScheduledEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScheduledEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScheduledEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>[]
        }
        upsert: {
          args: Prisma.ScheduledEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledEventPayload>
        }
        aggregate: {
          args: Prisma.ScheduledEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScheduledEvent>
        }
        groupBy: {
          args: Prisma.ScheduledEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduledEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScheduledEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduledEventCountAggregateOutputType> | number
        }
      }
    }
    Serials: {
      payload: Prisma.$SerialsPayload<ExtArgs>
      fields: Prisma.SerialsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SerialsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SerialsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>
        }
        findFirst: {
          args: Prisma.SerialsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SerialsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>
        }
        findMany: {
          args: Prisma.SerialsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>[]
        }
        create: {
          args: Prisma.SerialsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>
        }
        createMany: {
          args: Prisma.SerialsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SerialsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>[]
        }
        delete: {
          args: Prisma.SerialsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>
        }
        update: {
          args: Prisma.SerialsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>
        }
        deleteMany: {
          args: Prisma.SerialsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SerialsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SerialsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>[]
        }
        upsert: {
          args: Prisma.SerialsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SerialsPayload>
        }
        aggregate: {
          args: Prisma.SerialsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSerials>
        }
        groupBy: {
          args: Prisma.SerialsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SerialsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SerialsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SerialsCountAggregateOutputType> | number
        }
      }
    }
    SurveySession: {
      payload: Prisma.$SurveySessionPayload<ExtArgs>
      fields: Prisma.SurveySessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveySessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveySessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>
        }
        findFirst: {
          args: Prisma.SurveySessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveySessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>
        }
        findMany: {
          args: Prisma.SurveySessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>[]
        }
        create: {
          args: Prisma.SurveySessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>
        }
        createMany: {
          args: Prisma.SurveySessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveySessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>[]
        }
        delete: {
          args: Prisma.SurveySessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>
        }
        update: {
          args: Prisma.SurveySessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>
        }
        deleteMany: {
          args: Prisma.SurveySessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveySessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveySessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>[]
        }
        upsert: {
          args: Prisma.SurveySessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveySessionPayload>
        }
        aggregate: {
          args: Prisma.SurveySessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveySession>
        }
        groupBy: {
          args: Prisma.SurveySessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveySessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveySessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveySessionCountAggregateOutputType> | number
        }
      }
    }
    Unprocessed_Backlog_Materials: {
      payload: Prisma.$Unprocessed_Backlog_MaterialsPayload<ExtArgs>
      fields: Prisma.Unprocessed_Backlog_MaterialsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Unprocessed_Backlog_MaterialsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Unprocessed_Backlog_MaterialsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>
        }
        findFirst: {
          args: Prisma.Unprocessed_Backlog_MaterialsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Unprocessed_Backlog_MaterialsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>
        }
        findMany: {
          args: Prisma.Unprocessed_Backlog_MaterialsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>[]
        }
        create: {
          args: Prisma.Unprocessed_Backlog_MaterialsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>
        }
        createMany: {
          args: Prisma.Unprocessed_Backlog_MaterialsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Unprocessed_Backlog_MaterialsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>[]
        }
        delete: {
          args: Prisma.Unprocessed_Backlog_MaterialsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>
        }
        update: {
          args: Prisma.Unprocessed_Backlog_MaterialsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>
        }
        deleteMany: {
          args: Prisma.Unprocessed_Backlog_MaterialsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Unprocessed_Backlog_MaterialsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Unprocessed_Backlog_MaterialsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>[]
        }
        upsert: {
          args: Prisma.Unprocessed_Backlog_MaterialsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Unprocessed_Backlog_MaterialsPayload>
        }
        aggregate: {
          args: Prisma.Unprocessed_Backlog_MaterialsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnprocessed_Backlog_Materials>
        }
        groupBy: {
          args: Prisma.Unprocessed_Backlog_MaterialsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Unprocessed_Backlog_MaterialsGroupByOutputType>[]
        }
        count: {
          args: Prisma.Unprocessed_Backlog_MaterialsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Unprocessed_Backlog_MaterialsCountAggregateOutputType> | number
        }
      }
    }
    Volume_Holdings: {
      payload: Prisma.$Volume_HoldingsPayload<ExtArgs>
      fields: Prisma.Volume_HoldingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Volume_HoldingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Volume_HoldingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>
        }
        findFirst: {
          args: Prisma.Volume_HoldingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Volume_HoldingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>
        }
        findMany: {
          args: Prisma.Volume_HoldingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>[]
        }
        create: {
          args: Prisma.Volume_HoldingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>
        }
        createMany: {
          args: Prisma.Volume_HoldingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Volume_HoldingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>[]
        }
        delete: {
          args: Prisma.Volume_HoldingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>
        }
        update: {
          args: Prisma.Volume_HoldingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>
        }
        deleteMany: {
          args: Prisma.Volume_HoldingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Volume_HoldingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Volume_HoldingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>[]
        }
        upsert: {
          args: Prisma.Volume_HoldingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Volume_HoldingsPayload>
        }
        aggregate: {
          args: Prisma.Volume_HoldingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolume_Holdings>
        }
        groupBy: {
          args: Prisma.Volume_HoldingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Volume_HoldingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.Volume_HoldingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Volume_HoldingsCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ElectronicScalarFieldEnum = {
  id: 'id',
  libraryyear: 'libraryyear',
  entryid: 'entryid',
  eaccompanied_computer_cd_chinese: 'eaccompanied_computer_cd_chinese',
  eaccompanied_computer_cd_japanese: 'eaccompanied_computer_cd_japanese',
  eaccompanied_computer_cd_korean: 'eaccompanied_computer_cd_korean',
  eaccompanied_computer_cd_noncjk: 'eaccompanied_computer_cd_noncjk',
  eaccompanied_computer_cd_subtotal: 'eaccompanied_computer_cd_subtotal',
  eaccompanied_computer_memo: 'eaccompanied_computer_memo',
  eaccompanied_computer_title_chinese: 'eaccompanied_computer_title_chinese',
  eaccompanied_computer_title_japanese: 'eaccompanied_computer_title_japanese',
  eaccompanied_computer_title_korean: 'eaccompanied_computer_title_korean',
  eaccompanied_computer_title_noncjk: 'eaccompanied_computer_title_noncjk',
  eaccompanied_computer_title_subtotal: 'eaccompanied_computer_title_subtotal',
  efulltext_electronic_expenditure_chinese: 'efulltext_electronic_expenditure_chinese',
  efulltext_electronic_expenditure_japanese: 'efulltext_electronic_expenditure_japanese',
  efulltext_electronic_expenditure_korean: 'efulltext_electronic_expenditure_korean',
  efulltext_electronic_expenditure_noncjk: 'efulltext_electronic_expenditure_noncjk',
  efulltext_electronic_expenditure_subtotal: 'efulltext_electronic_expenditure_subtotal',
  efulltext_electronic_memo: 'efulltext_electronic_memo',
  efulltext_electronic_title_chinese: 'efulltext_electronic_title_chinese',
  efulltext_electronic_title_japanese: 'efulltext_electronic_title_japanese',
  efulltext_electronic_title_korean: 'efulltext_electronic_title_korean',
  efulltext_electronic_title_noncjk: 'efulltext_electronic_title_noncjk',
  efulltext_electronic_title_subtotal: 'efulltext_electronic_title_subtotal',
  egift_computer_cd_chinese: 'egift_computer_cd_chinese',
  egift_computer_cd_japanese: 'egift_computer_cd_japanese',
  egift_computer_cd_korean: 'egift_computer_cd_korean',
  egift_computer_cd_noncjk: 'egift_computer_cd_noncjk',
  egift_computer_cd_subtotal: 'egift_computer_cd_subtotal',
  egift_computer_memo: 'egift_computer_memo',
  egift_computer_title_chinese: 'egift_computer_title_chinese',
  egift_computer_title_japanese: 'egift_computer_title_japanese',
  egift_computer_title_korean: 'egift_computer_title_korean',
  egift_computer_title_noncjk: 'egift_computer_title_noncjk',
  egift_computer_title_subtotal: 'egift_computer_title_subtotal',
  egrand_memo: 'egrand_memo',
  egrand_total_cd_chinese: 'egrand_total_cd_chinese',
  egrand_total_cd_japanese: 'egrand_total_cd_japanese',
  egrand_total_cd_korean: 'egrand_total_cd_korean',
  egrand_total_cd_noncjk: 'egrand_total_cd_noncjk',
  egrand_total_cd_subtotal: 'egrand_total_cd_subtotal',
  egrand_total_title_chinese: 'egrand_total_title_chinese',
  egrand_total_title_japanese: 'egrand_total_title_japanese',
  egrand_total_title_korean: 'egrand_total_title_korean',
  egrand_total_title_noncjk: 'egrand_total_title_noncjk',
  egrand_total_title_subtotal: 'egrand_total_title_subtotal',
  egrandtotal_memo: 'egrandtotal_memo',
  eindex_electronic_expenditure_chinese: 'eindex_electronic_expenditure_chinese',
  eindex_electronic_expenditure_japanese: 'eindex_electronic_expenditure_japanese',
  eindex_electronic_expenditure_korean: 'eindex_electronic_expenditure_korean',
  eindex_electronic_expenditure_noncjk: 'eindex_electronic_expenditure_noncjk',
  eindex_electronic_expenditure_subtotal: 'eindex_electronic_expenditure_subtotal',
  eindex_electronic_memo: 'eindex_electronic_memo',
  eindex_electronic_title_chinese: 'eindex_electronic_title_chinese',
  eindex_electronic_title_japanese: 'eindex_electronic_title_japanese',
  eindex_electronic_title_korean: 'eindex_electronic_title_korean',
  eindex_electronic_title_noncjk: 'eindex_electronic_title_noncjk',
  eindex_electronic_title_subtotal: 'eindex_electronic_title_subtotal',
  enotes: 'enotes',
  eonetime_computer_cd_chinese: 'eonetime_computer_cd_chinese',
  eonetime_computer_cd_japanese: 'eonetime_computer_cd_japanese',
  eonetime_computer_cd_korean: 'eonetime_computer_cd_korean',
  eonetime_computer_cd_noncjk: 'eonetime_computer_cd_noncjk',
  eonetime_computer_cd_subtotal: 'eonetime_computer_cd_subtotal',
  eonetime_computer_expenditure_chinese: 'eonetime_computer_expenditure_chinese',
  eonetime_computer_expenditure_japanese: 'eonetime_computer_expenditure_japanese',
  eonetime_computer_expenditure_korean: 'eonetime_computer_expenditure_korean',
  eonetime_computer_expenditure_noncjk: 'eonetime_computer_expenditure_noncjk',
  eonetime_computer_expenditure_subtotal: 'eonetime_computer_expenditure_subtotal',
  eonetime_computer_memo: 'eonetime_computer_memo',
  eonetime_computer_title_chinese: 'eonetime_computer_title_chinese',
  eonetime_computer_title_japanese: 'eonetime_computer_title_japanese',
  eonetime_computer_title_korean: 'eonetime_computer_title_korean',
  eonetime_computer_title_noncjk: 'eonetime_computer_title_noncjk',
  eonetime_computer_title_subtotal: 'eonetime_computer_title_subtotal',
  eprevious_memo: 'eprevious_memo',
  eprevious_total_cd_chinese: 'eprevious_total_cd_chinese',
  eprevious_total_cd_japanese: 'eprevious_total_cd_japanese',
  eprevious_total_cd_korean: 'eprevious_total_cd_korean',
  eprevious_total_cd_noncjk: 'eprevious_total_cd_noncjk',
  eprevious_total_cd_subtotal: 'eprevious_total_cd_subtotal',
  eprevious_total_title_chinese: 'eprevious_total_title_chinese',
  eprevious_total_title_japanese: 'eprevious_total_title_japanese',
  eprevious_total_title_korean: 'eprevious_total_title_korean',
  eprevious_total_title_noncjk: 'eprevious_total_title_noncjk',
  eprevious_total_title_subtotal: 'eprevious_total_title_subtotal',
  etotal_computer_cd_chinese: 'etotal_computer_cd_chinese',
  etotal_computer_cd_japanese: 'etotal_computer_cd_japanese',
  etotal_computer_cd_korean: 'etotal_computer_cd_korean',
  etotal_computer_cd_noncjk: 'etotal_computer_cd_noncjk',
  etotal_computer_cd_subtotal: 'etotal_computer_cd_subtotal',
  etotal_computer_expenditure_chinese: 'etotal_computer_expenditure_chinese',
  etotal_computer_expenditure_japanese: 'etotal_computer_expenditure_japanese',
  etotal_computer_expenditure_korean: 'etotal_computer_expenditure_korean',
  etotal_computer_expenditure_noncjk: 'etotal_computer_expenditure_noncjk',
  etotal_computer_expenditure_subtotal: 'etotal_computer_expenditure_subtotal',
  etotal_computer_memo: 'etotal_computer_memo',
  etotal_computer_title_chinese: 'etotal_computer_title_chinese',
  etotal_computer_title_japanese: 'etotal_computer_title_japanese',
  etotal_computer_title_korean: 'etotal_computer_title_korean',
  etotal_computer_title_noncjk: 'etotal_computer_title_noncjk',
  etotal_computer_title_subtotal: 'etotal_computer_title_subtotal',
  etotal_electronic_expenditure_chinese: 'etotal_electronic_expenditure_chinese',
  etotal_electronic_expenditure_japanese: 'etotal_electronic_expenditure_japanese',
  etotal_electronic_expenditure_korean: 'etotal_electronic_expenditure_korean',
  etotal_electronic_expenditure_noncjk: 'etotal_electronic_expenditure_noncjk',
  etotal_electronic_expenditure_subtotal: 'etotal_electronic_expenditure_subtotal',
  etotal_electronic_memo: 'etotal_electronic_memo',
  etotal_electronic_title_chinese: 'etotal_electronic_title_chinese',
  etotal_electronic_title_japanese: 'etotal_electronic_title_japanese',
  etotal_electronic_title_korean: 'etotal_electronic_title_korean',
  etotal_electronic_title_noncjk: 'etotal_electronic_title_noncjk',
  etotal_electronic_title_subtotal: 'etotal_electronic_title_subtotal',
  etotal_expenditure_grandtotal: 'etotal_expenditure_grandtotal',
  etotal_expenditure_memo: 'etotal_expenditure_memo',
  etotal_expenditure_onetime: 'etotal_expenditure_onetime',
  etotal_expenditure_ongoing: 'etotal_expenditure_ongoing'
} as const

export type ElectronicScalarFieldEnum = (typeof ElectronicScalarFieldEnum)[keyof typeof ElectronicScalarFieldEnum]


export const Electronic_BooksScalarFieldEnum = {
  id: 'id',
  libraryyear: 'libraryyear',
  ebooks_purchased_volumes_chinese: 'ebooks_purchased_volumes_chinese',
  ebooks_purchased_volumes_japanese: 'ebooks_purchased_volumes_japanese',
  ebooks_purchased_volumes_korean: 'ebooks_purchased_volumes_korean',
  ebooks_purchased_volumes_noncjk: 'ebooks_purchased_volumes_noncjk',
  ebooks_purchased_volumes_subtotal: 'ebooks_purchased_volumes_subtotal',
  ebooks_purchased_titles_chinese: 'ebooks_purchased_titles_chinese',
  ebooks_purchased_titles_japanese: 'ebooks_purchased_titles_japanese',
  ebooks_purchased_titles_korean: 'ebooks_purchased_titles_korean',
  ebooks_purchased_titles_noncjk: 'ebooks_purchased_titles_noncjk',
  ebooks_purchased_titles_subtotal: 'ebooks_purchased_titles_subtotal',
  ebooks_nonpurchased_volumes_chinese: 'ebooks_nonpurchased_volumes_chinese',
  ebooks_nonpurchased_volumes_japanese: 'ebooks_nonpurchased_volumes_japanese',
  ebooks_nonpurchased_volumes_korean: 'ebooks_nonpurchased_volumes_korean',
  ebooks_nonpurchased_volumes_noncjk: 'ebooks_nonpurchased_volumes_noncjk',
  ebooks_nonpurchased_volumes_subtotal: 'ebooks_nonpurchased_volumes_subtotal',
  ebooks_nonpurchased_titles_chinese: 'ebooks_nonpurchased_titles_chinese',
  ebooks_nonpurchased_titles_japanese: 'ebooks_nonpurchased_titles_japanese',
  ebooks_nonpurchased_titles_korean: 'ebooks_nonpurchased_titles_korean',
  ebooks_nonpurchased_titles_noncjk: 'ebooks_nonpurchased_titles_noncjk',
  ebooks_nonpurchased_titles_subtotal: 'ebooks_nonpurchased_titles_subtotal',
  ebooks_subscription_volumes_chinese: 'ebooks_subscription_volumes_chinese',
  ebooks_subscription_volumes_japanese: 'ebooks_subscription_volumes_japanese',
  ebooks_subscription_volumes_korean: 'ebooks_subscription_volumes_korean',
  ebooks_subscription_volumes_noncjk: 'ebooks_subscription_volumes_noncjk',
  ebooks_subscription_volumes_subtotal: 'ebooks_subscription_volumes_subtotal',
  ebooks_subscription_titles_chinese: 'ebooks_subscription_titles_chinese',
  ebooks_subscription_titles_japanese: 'ebooks_subscription_titles_japanese',
  ebooks_subscription_titles_korean: 'ebooks_subscription_titles_korean',
  ebooks_subscription_titles_noncjk: 'ebooks_subscription_titles_noncjk',
  ebooks_subscription_titles_subtotal: 'ebooks_subscription_titles_subtotal',
  ebooks_total_volumes: 'ebooks_total_volumes',
  ebooks_total_titles: 'ebooks_total_titles',
  ebooks_expenditure_grandtotal: 'ebooks_expenditure_grandtotal',
  ebooks_notes: 'ebooks_notes',
  ebooks_purchased_prev_titles_chinese: 'ebooks_purchased_prev_titles_chinese',
  ebooks_purchased_prev_titles_japanese: 'ebooks_purchased_prev_titles_japanese',
  ebooks_purchased_prev_titles_korean: 'ebooks_purchased_prev_titles_korean',
  ebooks_purchased_prev_titles_noncjk: 'ebooks_purchased_prev_titles_noncjk',
  ebooks_purchased_prev_titles_subtotal: 'ebooks_purchased_prev_titles_subtotal',
  ebooks_purchased_add_titles_chinese: 'ebooks_purchased_add_titles_chinese',
  ebooks_purchased_add_titles_japanese: 'ebooks_purchased_add_titles_japanese',
  ebooks_purchased_add_titles_korean: 'ebooks_purchased_add_titles_korean',
  ebooks_purchased_add_titles_noncjk: 'ebooks_purchased_add_titles_noncjk',
  ebooks_purchased_add_titles_subtotal: 'ebooks_purchased_add_titles_subtotal',
  ebooks_purchased_prev_volumes_chinese: 'ebooks_purchased_prev_volumes_chinese',
  ebooks_purchased_prev_volumes_japanese: 'ebooks_purchased_prev_volumes_japanese',
  ebooks_purchased_prev_volumes_korean: 'ebooks_purchased_prev_volumes_korean',
  ebooks_purchased_prev_volumes_noncjk: 'ebooks_purchased_prev_volumes_noncjk',
  ebooks_purchased_prev_volumes_subtotal: 'ebooks_purchased_prev_volumes_subtotal',
  ebooks_purchased_add_volumes_chinese: 'ebooks_purchased_add_volumes_chinese',
  ebooks_purchased_add_volumes_japanese: 'ebooks_purchased_add_volumes_japanese',
  ebooks_purchased_add_volumes_korean: 'ebooks_purchased_add_volumes_korean',
  ebooks_purchased_add_volumes_noncjk: 'ebooks_purchased_add_volumes_noncjk',
  ebooks_purchased_add_volumes_subtotal: 'ebooks_purchased_add_volumes_subtotal'
} as const

export type Electronic_BooksScalarFieldEnum = (typeof Electronic_BooksScalarFieldEnum)[keyof typeof Electronic_BooksScalarFieldEnum]


export const Entry_StatusScalarFieldEnum = {
  id: 'id',
  fiscal_support: 'fiscal_support',
  monographic_acquisitions: 'monographic_acquisitions',
  other_holdings: 'other_holdings',
  participating_libraries_information: 'participating_libraries_information',
  personnel_support_fte: 'personnel_support_fte',
  public_services: 'public_services',
  serials: 'serials',
  unprocessed_backlog_materials: 'unprocessed_backlog_materials',
  volume_holdings: 'volume_holdings',
  electronic: 'electronic',
  electronic_books: 'electronic_books',
  espublished: 'espublished',
  libraryyear: 'libraryyear'
} as const

export type Entry_StatusScalarFieldEnum = (typeof Entry_StatusScalarFieldEnum)[keyof typeof Entry_StatusScalarFieldEnum]


export const Fiscal_SupportScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  fschinese_appropriations_monographic: 'fschinese_appropriations_monographic',
  fschinese_appropriations_serial: 'fschinese_appropriations_serial',
  fschinese_appropriations_other_material: 'fschinese_appropriations_other_material',
  fschinese_appropriations_electronic: 'fschinese_appropriations_electronic',
  fschinese_appropriations_subtotal: 'fschinese_appropriations_subtotal',
  fsjapanese_appropriations_monographic: 'fsjapanese_appropriations_monographic',
  fsjapanese_appropriations_serial: 'fsjapanese_appropriations_serial',
  fsjapanese_appropriations_other_material: 'fsjapanese_appropriations_other_material',
  fsjapanese_appropriations_electronic: 'fsjapanese_appropriations_electronic',
  fsjapanese_appropriations_subtotal: 'fsjapanese_appropriations_subtotal',
  fskorean_appropriations_monographic: 'fskorean_appropriations_monographic',
  fskorean_appropriations_serial: 'fskorean_appropriations_serial',
  fskorean_appropriations_other_material: 'fskorean_appropriations_other_material',
  fskorean_appropriations_electronic: 'fskorean_appropriations_electronic',
  fskorean_appropriations_subtotal: 'fskorean_appropriations_subtotal',
  fsnoncjk_appropriations_monographic: 'fsnoncjk_appropriations_monographic',
  fsnoncjk_appropriations_serial: 'fsnoncjk_appropriations_serial',
  fsnoncjk_appropriations_other_material: 'fsnoncjk_appropriations_other_material',
  fsnoncjk_appropriations_electronic: 'fsnoncjk_appropriations_electronic',
  fsnoncjk_appropriations_subtotal: 'fsnoncjk_appropriations_subtotal',
  fstotal_appropriations: 'fstotal_appropriations',
  fsendowments_chinese: 'fsendowments_chinese',
  fsendowments_japanese: 'fsendowments_japanese',
  fsendowments_korean: 'fsendowments_korean',
  fsendowments_subtotal: 'fsendowments_subtotal',
  fsgrants_chinese: 'fsgrants_chinese',
  fsgrants_japanese: 'fsgrants_japanese',
  fsgrants_korean: 'fsgrants_korean',
  fsgrants_subtotal: 'fsgrants_subtotal',
  fseast_asian_program_support_chinese: 'fseast_asian_program_support_chinese',
  fseast_asian_program_support_japanese: 'fseast_asian_program_support_japanese',
  fseast_asian_program_support_korean: 'fseast_asian_program_support_korean',
  fseast_asian_program_support_subtotal: 'fseast_asian_program_support_subtotal',
  fstotal_acquisition_budget: 'fstotal_acquisition_budget',
  fschinese_appropriations_subtotal_manual: 'fschinese_appropriations_subtotal_manual',
  fsjapanese_appropriations_subtotal_manual: 'fsjapanese_appropriations_subtotal_manual',
  fskorean_appropriations_subtotal_manual: 'fskorean_appropriations_subtotal_manual',
  fsnoncjk_appropriations_subtotal_manual: 'fsnoncjk_appropriations_subtotal_manual',
  fstotal_appropriations_manual: 'fstotal_appropriations_manual',
  fsendowments_subtotal_manual: 'fsendowments_subtotal_manual',
  fsgrants_subtotal_manual: 'fsgrants_subtotal_manual',
  fseast_asian_program_support_subtotal_manual: 'fseast_asian_program_support_subtotal_manual',
  fsnotes: 'fsnotes',
  libraryyear: 'libraryyear',
  fsendowments_noncjk: 'fsendowments_noncjk',
  fsgrants_noncjk: 'fsgrants_noncjk',
  fseast_asian_program_support_noncjk: 'fseast_asian_program_support_noncjk'
} as const

export type Fiscal_SupportScalarFieldEnum = (typeof Fiscal_SupportScalarFieldEnum)[keyof typeof Fiscal_SupportScalarFieldEnum]


export const LibraryScalarFieldEnum = {
  id: 'id',
  type: 'type',
  library_name: 'library_name',
  plilaw: 'plilaw',
  plimed: 'plimed',
  plisubmitter_first_name: 'plisubmitter_first_name',
  plisubmitter_last_name: 'plisubmitter_last_name',
  pliposition_title: 'pliposition_title',
  pliwork_phone: 'pliwork_phone',
  plie_mail: 'plie_mail',
  plifax_number: 'plifax_number',
  pliinput_as_of_date: 'pliinput_as_of_date',
  password: 'password',
  plibibliographic: 'plibibliographic',
  pliconsortia: 'pliconsortia',
  plisystem_vendor: 'plisystem_vendor',
  pliopac: 'pliopac',
  plihome_page: 'plihome_page',
  plionline_catalog: 'plionline_catalog',
  pliunique: 'pliunique',
  pliestablishedyear: 'pliestablishedyear',
  library_number: 'library_number',
  pliregion: 'pliregion',
  collection_title: 'collection_title',
  collection_incharge_title: 'collection_incharge_title',
  collection_organized_under: 'collection_organized_under',
  collection_head_reports_to: 'collection_head_reports_to',
  collection_top_department: 'collection_top_department',
  collection_next_position_title: 'collection_next_position_title',
  collection_other_departments: 'collection_other_departments',
  collection_librarians_groups: 'collection_librarians_groups',
  collection_type: 'collection_type',
  shelving_type: 'shelving_type',
  consultation_type: 'consultation_type',
  teaching_type: 'teaching_type',
  acquisition_type: 'acquisition_type',
  cataloging_type: 'cataloging_type',
  circulation_type: 'circulation_type',
  date_last_changed: 'date_last_changed',
  notes: 'notes',
  hideinlibrarylist: 'hideinlibrarylist'
} as const

export type LibraryScalarFieldEnum = (typeof LibraryScalarFieldEnum)[keyof typeof LibraryScalarFieldEnum]


export const LibraryYear_ListAVScalarFieldEnum = {
  libraryyear_id: 'libraryyear_id',
  listav_id: 'listav_id'
} as const

export type LibraryYear_ListAVScalarFieldEnum = (typeof LibraryYear_ListAVScalarFieldEnum)[keyof typeof LibraryYear_ListAVScalarFieldEnum]


export const LibraryYear_ListEBookScalarFieldEnum = {
  libraryyear_id: 'libraryyear_id',
  listebook_id: 'listebook_id'
} as const

export type LibraryYear_ListEBookScalarFieldEnum = (typeof LibraryYear_ListEBookScalarFieldEnum)[keyof typeof LibraryYear_ListEBookScalarFieldEnum]


export const LibraryYear_ListEJournalScalarFieldEnum = {
  libraryyear_id: 'libraryyear_id',
  listejournal_id: 'listejournal_id'
} as const

export type LibraryYear_ListEJournalScalarFieldEnum = (typeof LibraryYear_ListEJournalScalarFieldEnum)[keyof typeof LibraryYear_ListEJournalScalarFieldEnum]


export const List_AVScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  cjk_title: 'cjk_title',
  romanized_title: 'romanized_title',
  subtitle: 'subtitle',
  publisher: 'publisher',
  description: 'description',
  notes: 'notes',
  data_source: 'data_source',
  updated_at: 'updated_at',
  is_global: 'is_global',
  libraryyear: 'libraryyear'
} as const

export type List_AVScalarFieldEnum = (typeof List_AVScalarFieldEnum)[keyof typeof List_AVScalarFieldEnum]


export const List_AV_CountsScalarFieldEnum = {
  id: 'id',
  titles: 'titles',
  year: 'year',
  updatedat: 'updatedat',
  ishidden: 'ishidden',
  listav: 'listav'
} as const

export type List_AV_CountsScalarFieldEnum = (typeof List_AV_CountsScalarFieldEnum)[keyof typeof List_AV_CountsScalarFieldEnum]


export const List_AV_LanguageScalarFieldEnum = {
  listav_id: 'listav_id',
  language_id: 'language_id'
} as const

export type List_AV_LanguageScalarFieldEnum = (typeof List_AV_LanguageScalarFieldEnum)[keyof typeof List_AV_LanguageScalarFieldEnum]


export const ListCustomOtherHoldingsScalarFieldEnum = {
  id: 'id',
  label: 'label'
} as const

export type ListCustomOtherHoldingsScalarFieldEnum = (typeof ListCustomOtherHoldingsScalarFieldEnum)[keyof typeof ListCustomOtherHoldingsScalarFieldEnum]


export const List_EBookScalarFieldEnum = {
  id: 'id',
  title: 'title',
  sub_series_number: 'sub_series_number',
  publisher: 'publisher',
  description: 'description',
  notes: 'notes',
  updated_at: 'updated_at',
  subtitle: 'subtitle',
  cjk_title: 'cjk_title',
  romanized_title: 'romanized_title',
  data_source: 'data_source',
  is_global: 'is_global',
  libraryyear: 'libraryyear'
} as const

export type List_EBookScalarFieldEnum = (typeof List_EBookScalarFieldEnum)[keyof typeof List_EBookScalarFieldEnum]


export const List_EBook_CountsScalarFieldEnum = {
  id: 'id',
  titles: 'titles',
  volumes: 'volumes',
  year: 'year',
  updatedat: 'updatedat',
  chapters: 'chapters',
  ishidden: 'ishidden',
  listebook: 'listebook'
} as const

export type List_EBook_CountsScalarFieldEnum = (typeof List_EBook_CountsScalarFieldEnum)[keyof typeof List_EBook_CountsScalarFieldEnum]


export const List_EBook_LanguageScalarFieldEnum = {
  listebook_id: 'listebook_id',
  language_id: 'language_id'
} as const

export type List_EBook_LanguageScalarFieldEnum = (typeof List_EBook_LanguageScalarFieldEnum)[keyof typeof List_EBook_LanguageScalarFieldEnum]


export const List_EJournalScalarFieldEnum = {
  id: 'id',
  title: 'title',
  sub_series_number: 'sub_series_number',
  publisher: 'publisher',
  description: 'description',
  notes: 'notes',
  updated_at: 'updated_at',
  subtitle: 'subtitle',
  series: 'series',
  vendor: 'vendor',
  cjk_title: 'cjk_title',
  romanized_title: 'romanized_title',
  data_source: 'data_source',
  is_global: 'is_global',
  libraryyear: 'libraryyear'
} as const

export type List_EJournalScalarFieldEnum = (typeof List_EJournalScalarFieldEnum)[keyof typeof List_EJournalScalarFieldEnum]


export const List_EJournal_CountsScalarFieldEnum = {
  id: 'id',
  journals: 'journals',
  dbs: 'dbs',
  year: 'year',
  updatedat: 'updatedat',
  ishidden: 'ishidden',
  listejournal: 'listejournal'
} as const

export type List_EJournal_CountsScalarFieldEnum = (typeof List_EJournal_CountsScalarFieldEnum)[keyof typeof List_EJournal_CountsScalarFieldEnum]


export const List_EJournal_LanguageScalarFieldEnum = {
  listejournal_id: 'listejournal_id',
  language_id: 'language_id'
} as const

export type List_EJournal_LanguageScalarFieldEnum = (typeof List_EJournal_LanguageScalarFieldEnum)[keyof typeof List_EJournal_LanguageScalarFieldEnum]


export const Monographic_AcquisitionsScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  mapurchased_titles_chinese: 'mapurchased_titles_chinese',
  mapurchased_titles_japanese: 'mapurchased_titles_japanese',
  mapurchased_titles_korean: 'mapurchased_titles_korean',
  mapurchased_titles_noncjk: 'mapurchased_titles_noncjk',
  mapurchased_titles_subtotal: 'mapurchased_titles_subtotal',
  mapurchased_volumes_chinese: 'mapurchased_volumes_chinese',
  mapurchased_volumes_japanese: 'mapurchased_volumes_japanese',
  mapurchased_volumes_korean: 'mapurchased_volumes_korean',
  mapurchased_volumes_noncjk: 'mapurchased_volumes_noncjk',
  mapurchased_volumes_subtotal: 'mapurchased_volumes_subtotal',
  manonpurchased_titles_chinese: 'manonpurchased_titles_chinese',
  manonpurchased_titles_japanese: 'manonpurchased_titles_japanese',
  manonpurchased_titles_korean: 'manonpurchased_titles_korean',
  manonpurchased_titles_noncjk: 'manonpurchased_titles_noncjk',
  manonpurchased_titles_subtotal: 'manonpurchased_titles_subtotal',
  manonpurchased_volumes_chinese: 'manonpurchased_volumes_chinese',
  manonpurchased_volumes_japanese: 'manonpurchased_volumes_japanese',
  manonpurchased_volumes_korean: 'manonpurchased_volumes_korean',
  manonpurchased_volumes_noncjk: 'manonpurchased_volumes_noncjk',
  manonpurchased_volumes_subtotal: 'manonpurchased_volumes_subtotal',
  matotal_titles: 'matotal_titles',
  matotal_volumes: 'matotal_volumes',
  manotes: 'manotes',
  libraryyear: 'libraryyear'
} as const

export type Monographic_AcquisitionsScalarFieldEnum = (typeof Monographic_AcquisitionsScalarFieldEnum)[keyof typeof Monographic_AcquisitionsScalarFieldEnum]


export const Other_HoldingsScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  libraryyear: 'libraryyear',
  ohaudio_chinese: 'ohaudio_chinese',
  ohaudio_japanese: 'ohaudio_japanese',
  ohaudio_korean: 'ohaudio_korean',
  ohaudio_noncjk: 'ohaudio_noncjk',
  ohaudio_subtotal: 'ohaudio_subtotal',
  ohcarto_graphic_chinese: 'ohcarto_graphic_chinese',
  ohcarto_graphic_japanese: 'ohcarto_graphic_japanese',
  ohcarto_graphic_korean: 'ohcarto_graphic_korean',
  ohcarto_graphic_noncjk: 'ohcarto_graphic_noncjk',
  ohcarto_graphic_subtotal: 'ohcarto_graphic_subtotal',
  ohcomputer_cd_chinese: 'ohcomputer_cd_chinese',
  ohcomputer_cd_japanese: 'ohcomputer_cd_japanese',
  ohcomputer_cd_korean: 'ohcomputer_cd_korean',
  ohcomputer_cd_noncjk: 'ohcomputer_cd_noncjk',
  ohcomputer_cd_subtotal: 'ohcomputer_cd_subtotal',
  ohcomputer_files_chinese: 'ohcomputer_files_chinese',
  ohcomputer_files_japanese: 'ohcomputer_files_japanese',
  ohcomputer_files_korean: 'ohcomputer_files_korean',
  ohcomputer_files_noncjk: 'ohcomputer_files_noncjk',
  ohcomputer_files_subtotal: 'ohcomputer_files_subtotal',
  ohcustom1_label: 'ohcustom1_label',
  ohcustom1chinese: 'ohcustom1chinese',
  ohcustom1japanese: 'ohcustom1japanese',
  ohcustom1korean: 'ohcustom1korean',
  ohcustom1noncjk: 'ohcustom1noncjk',
  ohcustom1subtotal: 'ohcustom1subtotal',
  ohcustom2_label: 'ohcustom2_label',
  ohcustom2chinese: 'ohcustom2chinese',
  ohcustom2japanese: 'ohcustom2japanese',
  ohcustom2korean: 'ohcustom2korean',
  ohcustom2noncjk: 'ohcustom2noncjk',
  ohcustom2subtotal: 'ohcustom2subtotal',
  ohcustom3_label: 'ohcustom3_label',
  ohcustom3chinese: 'ohcustom3chinese',
  ohcustom3japanese: 'ohcustom3japanese',
  ohcustom3korean: 'ohcustom3korean',
  ohcustom3noncjk: 'ohcustom3noncjk',
  ohcustom3subtotal: 'ohcustom3subtotal',
  ohcustom4_label: 'ohcustom4_label',
  ohcustom4chinese: 'ohcustom4chinese',
  ohcustom4japanese: 'ohcustom4japanese',
  ohcustom4korean: 'ohcustom4korean',
  ohcustom4noncjk: 'ohcustom4noncjk',
  ohcustom4subtotal: 'ohcustom4subtotal',
  ohcustomsubtotal: 'ohcustomsubtotal',
  ohdvd_chinese: 'ohdvd_chinese',
  ohdvd_japanese: 'ohdvd_japanese',
  ohdvd_korean: 'ohdvd_korean',
  ohdvd_noncjk: 'ohdvd_noncjk',
  ohdvd_subtotal: 'ohdvd_subtotal',
  ohfilm_video_chinese: 'ohfilm_video_chinese',
  ohfilm_video_japanese: 'ohfilm_video_japanese',
  ohfilm_video_korean: 'ohfilm_video_korean',
  ohfilm_video_noncjk: 'ohfilm_video_noncjk',
  ohfilm_video_subtotal: 'ohfilm_video_subtotal',
  ohgrandtotal: 'ohgrandtotal',
  ohmicroform_chinese: 'ohmicroform_chinese',
  ohmicroform_japanese: 'ohmicroform_japanese',
  ohmicroform_korean: 'ohmicroform_korean',
  ohmicroform_noncjk: 'ohmicroform_noncjk',
  ohmicroform_subtotal: 'ohmicroform_subtotal',
  ohnotes: 'ohnotes',
  ohonlineimagechinese: 'ohonlineimagechinese',
  ohonlineimagejapanese: 'ohonlineimagejapanese',
  ohonlineimagekorean: 'ohonlineimagekorean',
  ohonlineimagenoncjk: 'ohonlineimagenoncjk',
  ohonlineimagesubtotal: 'ohonlineimagesubtotal',
  ohonlinemapchinese: 'ohonlinemapchinese',
  ohonlinemapjapanese: 'ohonlinemapjapanese',
  ohonlinemapkorean: 'ohonlinemapkorean',
  ohonlinemapnoncjk: 'ohonlinemapnoncjk',
  ohonlinemapsubtotal: 'ohonlinemapsubtotal',
  ohotherchinese: 'ohotherchinese',
  ohotherjapanese: 'ohotherjapanese',
  ohotherkorean: 'ohotherkorean',
  ohothernoncjk: 'ohothernoncjk',
  ohothersubtotal: 'ohothersubtotal',
  ohstreamingchinese: 'ohstreamingchinese',
  ohstreamingjapanese: 'ohstreamingjapanese',
  ohstreamingkorean: 'ohstreamingkorean',
  ohstreamingnoncjk: 'ohstreamingnoncjk',
  ohstreamingsubtotal: 'ohstreamingsubtotal',
  ohstreamingvideochinese: 'ohstreamingvideochinese',
  ohstreamingvideojapanese: 'ohstreamingvideojapanese',
  ohstreamingvideokorean: 'ohstreamingvideokorean',
  ohstreamingvideononcjk: 'ohstreamingvideononcjk',
  ohstreamingvideosubtotal: 'ohstreamingvideosubtotal'
} as const

export type Other_HoldingsScalarFieldEnum = (typeof Other_HoldingsScalarFieldEnum)[keyof typeof Other_HoldingsScalarFieldEnum]


export const Personnel_SupportScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  libraryyear: 'libraryyear',
  psfnotes: 'psfnotes',
  psfosacquisition: 'psfosacquisition',
  psfosprocessing: 'psfosprocessing',
  psfothers: 'psfothers',
  psfprofessional_chinese: 'psfprofessional_chinese',
  psfprofessional_eastasian: 'psfprofessional_eastasian',
  psfprofessional_japanese: 'psfprofessional_japanese',
  psfprofessional_korean: 'psfprofessional_korean',
  psfprofessional_subtotal: 'psfprofessional_subtotal',
  psfstudent_assistants_chinese: 'psfstudent_assistants_chinese',
  psfstudent_assistants_eastasian: 'psfstudent_assistants_eastasian',
  psfstudent_assistants_japanese: 'psfstudent_assistants_japanese',
  psfstudent_assistants_korean: 'psfstudent_assistants_korean',
  psfstudent_assistants_subtotal: 'psfstudent_assistants_subtotal',
  psfsupport_staff_chinese: 'psfsupport_staff_chinese',
  psfsupport_staff_eastasian: 'psfsupport_staff_eastasian',
  psfsupport_staff_japanese: 'psfsupport_staff_japanese',
  psfsupport_staff_korean: 'psfsupport_staff_korean',
  psfsupport_staff_subtotal: 'psfsupport_staff_subtotal',
  psftotal: 'psftotal'
} as const

export type Personnel_SupportScalarFieldEnum = (typeof Personnel_SupportScalarFieldEnum)[keyof typeof Personnel_SupportScalarFieldEnum]


export const Public_ServicesScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  libraryyear: 'libraryyear',
  pspresentations_subtotal: 'pspresentations_subtotal',
  pspresentation_participants_subtotal: 'pspresentation_participants_subtotal',
  psreference_transactions_subtotal: 'psreference_transactions_subtotal',
  pstotal_circulations_subtotal: 'pstotal_circulations_subtotal',
  pslending_requests_filled_subtotal: 'pslending_requests_filled_subtotal',
  pslending_requests_unfilled_subtotal: 'pslending_requests_unfilled_subtotal',
  psborrowing_requests_filled_subtotal: 'psborrowing_requests_filled_subtotal',
  psborrowing_requests_unfilled_subtotal: 'psborrowing_requests_unfilled_subtotal',
  psnotes: 'psnotes'
} as const

export type Public_ServicesScalarFieldEnum = (typeof Public_ServicesScalarFieldEnum)[keyof typeof Public_ServicesScalarFieldEnum]


export const Exclude_YearScalarFieldEnum = {
  exyear: 'exyear'
} as const

export type Exclude_YearScalarFieldEnum = (typeof Exclude_YearScalarFieldEnum)[keyof typeof Exclude_YearScalarFieldEnum]


export const ReflibrarytypeScalarFieldEnum = {
  id: 'id',
  librarytype: 'librarytype'
} as const

export type ReflibrarytypeScalarFieldEnum = (typeof ReflibrarytypeScalarFieldEnum)[keyof typeof ReflibrarytypeScalarFieldEnum]


export const ReflibraryregionScalarFieldEnum = {
  id: 'id',
  libraryregion: 'libraryregion'
} as const

export type ReflibraryregionScalarFieldEnum = (typeof ReflibraryregionScalarFieldEnum)[keyof typeof ReflibraryregionScalarFieldEnum]


export const LanguageScalarFieldEnum = {
  id: 'id',
  short: 'short',
  full: 'full'
} as const

export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


export const Library_YearScalarFieldEnum = {
  id: 'id',
  library: 'library',
  is_open_for_editing: 'is_open_for_editing',
  admin_notes: 'admin_notes',
  year: 'year',
  updated_at: 'updated_at',
  is_active: 'is_active',
  opening_date: 'opening_date',
  closing_date: 'closing_date',
  fiscal_year_start: 'fiscal_year_start',
  fiscal_year_end: 'fiscal_year_end',
  publication_date: 'publication_date',
  broadcast_sent: 'broadcast_sent'
} as const

export type Library_YearScalarFieldEnum = (typeof Library_YearScalarFieldEnum)[keyof typeof Library_YearScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  username: 'username',
  password: 'password',
  firstname: 'firstname',
  lastname: 'lastname',
  isactive: 'isactive',
  lastlogin_at: 'lastlogin_at',
  requires_password_reset: 'requires_password_reset',
  password_reset_token: 'password_reset_token',
  password_reset_expires: 'password_reset_expires',
  email_verified: 'email_verified',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  sessionToken: 'sessionToken',
  userId: 'userId',
  expires: 'expires'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const VerificationTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  username: 'username',
  action: 'action',
  table_name: 'table_name',
  record_id: 'record_id',
  old_values: 'old_values',
  new_values: 'new_values',
  ip_address: 'ip_address',
  user_agent: 'user_agent',
  timestamp: 'timestamp',
  success: 'success',
  error_message: 'error_message'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const User_LibraryScalarFieldEnum = {
  user_id: 'user_id',
  library_id: 'library_id'
} as const

export type User_LibraryScalarFieldEnum = (typeof User_LibraryScalarFieldEnum)[keyof typeof User_LibraryScalarFieldEnum]


export const RoleScalarFieldEnum = {
  id: 'id',
  role: 'role',
  name: 'name'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const Users_RolesScalarFieldEnum = {
  user_id: 'user_id',
  role_id: 'role_id'
} as const

export type Users_RolesScalarFieldEnum = (typeof Users_RolesScalarFieldEnum)[keyof typeof Users_RolesScalarFieldEnum]


export const ScheduledEventScalarFieldEnum = {
  id: 'id',
  event_type: 'event_type',
  year: 'year',
  scheduled_date: 'scheduled_date',
  status: 'status',
  created_by: 'created_by',
  created_at: 'created_at',
  completed_at: 'completed_at',
  cancelled_at: 'cancelled_at',
  notes: 'notes'
} as const

export type ScheduledEventScalarFieldEnum = (typeof ScheduledEventScalarFieldEnum)[keyof typeof ScheduledEventScalarFieldEnum]


export const SerialsScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  spurchased_chinese: 'spurchased_chinese',
  spurchased_japanese: 'spurchased_japanese',
  spurchased_korean: 'spurchased_korean',
  spurchased_noncjk: 'spurchased_noncjk',
  spurchased_subtotal: 'spurchased_subtotal',
  snonpurchased_chinese: 'snonpurchased_chinese',
  snonpurchased_japanese: 'snonpurchased_japanese',
  snonpurchased_korean: 'snonpurchased_korean',
  snonpurchased_noncjk: 'snonpurchased_noncjk',
  snonpurchased_subtotal: 'snonpurchased_subtotal',
  stotal_chinese: 'stotal_chinese',
  stotal_japanese: 'stotal_japanese',
  stotal_korean: 'stotal_korean',
  stotal_noncjk: 'stotal_noncjk',
  s_epurchased_chinese: 's_epurchased_chinese',
  s_epurchased_japanese: 's_epurchased_japanese',
  s_epurchased_korean: 's_epurchased_korean',
  s_epurchased_noncjk: 's_epurchased_noncjk',
  s_epurchased_subtotal: 's_epurchased_subtotal',
  s_enonpurchased_chinese: 's_enonpurchased_chinese',
  s_enonpurchased_japanese: 's_enonpurchased_japanese',
  s_enonpurchased_korean: 's_enonpurchased_korean',
  s_enonpurchased_noncjk: 's_enonpurchased_noncjk',
  s_enonpurchased_subtotal: 's_enonpurchased_subtotal',
  s_etotal_chinese: 's_etotal_chinese',
  s_etotal_japanese: 's_etotal_japanese',
  s_etotal_korean: 's_etotal_korean',
  s_etotal_noncjk: 's_etotal_noncjk',
  speriodical_cur_chinese: 'speriodical_cur_chinese',
  speriodical_cur_japanese: 'speriodical_cur_japanese',
  speriodical_cur_korean: 'speriodical_cur_korean',
  speriodical_ncur_chinese: 'speriodical_ncur_chinese',
  speriodical_ncur_japanese: 'speriodical_ncur_japanese',
  speriodical_ncur_korean: 'speriodical_ncur_korean',
  speriodical_subtotal_chinese: 'speriodical_subtotal_chinese',
  speriodical_subtotal_japanese: 'speriodical_subtotal_japanese',
  speriodical_subtotal_korean: 'speriodical_subtotal_korean',
  speriodical_subtotal: 'speriodical_subtotal',
  snewspaper_cur_chinese: 'snewspaper_cur_chinese',
  snewspaper_cur_japanese: 'snewspaper_cur_japanese',
  snewspaper_cur_korean: 'snewspaper_cur_korean',
  snewspaper_ncur_chinese: 'snewspaper_ncur_chinese',
  snewspaper_ncur_japanese: 'snewspaper_ncur_japanese',
  snewspaper_ncur_korean: 'snewspaper_ncur_korean',
  snewspaper_subtotal_chinese: 'snewspaper_subtotal_chinese',
  snewspaper_subtotal_japanese: 'snewspaper_subtotal_japanese',
  snewspaper_subtotal_korean: 'snewspaper_subtotal_korean',
  snewspaper_subtotal: 'snewspaper_subtotal',
  sgrandtotal: 'sgrandtotal',
  s_egrandtotal: 's_egrandtotal',
  snotes: 'snotes',
  libraryyear: 'libraryyear'
} as const

export type SerialsScalarFieldEnum = (typeof SerialsScalarFieldEnum)[keyof typeof SerialsScalarFieldEnum]


export const SurveySessionScalarFieldEnum = {
  id: 'id',
  academicYear: 'academicYear',
  openingDate: 'openingDate',
  closingDate: 'closingDate',
  isOpen: 'isOpen',
  notifiedOnOpen: 'notifiedOnOpen',
  notifiedOnClose: 'notifiedOnClose',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy'
} as const

export type SurveySessionScalarFieldEnum = (typeof SurveySessionScalarFieldEnum)[keyof typeof SurveySessionScalarFieldEnum]


export const Unprocessed_Backlog_MaterialsScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  ubchinese: 'ubchinese',
  ubjapanese: 'ubjapanese',
  ubkorean: 'ubkorean',
  ubnoncjk: 'ubnoncjk',
  ubtotal: 'ubtotal',
  ubcatalog_title: 'ubcatalog_title',
  ubcatalog_volume: 'ubcatalog_volume',
  ub_title: 'ub_title',
  ub_volume: 'ub_volume',
  ubnotes: 'ubnotes',
  libraryyear: 'libraryyear'
} as const

export type Unprocessed_Backlog_MaterialsScalarFieldEnum = (typeof Unprocessed_Backlog_MaterialsScalarFieldEnum)[keyof typeof Unprocessed_Backlog_MaterialsScalarFieldEnum]


export const Volume_HoldingsScalarFieldEnum = {
  id: 'id',
  entryid: 'entryid',
  vhprevious_year_chinese: 'vhprevious_year_chinese',
  vhprevious_year_japanese: 'vhprevious_year_japanese',
  vhprevious_year_korean: 'vhprevious_year_korean',
  vhprevious_year_noncjk: 'vhprevious_year_noncjk',
  vhprevious_year_subtotal: 'vhprevious_year_subtotal',
  vhadded_gross_chinese: 'vhadded_gross_chinese',
  vhadded_gross_japanese: 'vhadded_gross_japanese',
  vhadded_gross_korean: 'vhadded_gross_korean',
  vhadded_gross_noncjk: 'vhadded_gross_noncjk',
  vhadded_gross_subtotal: 'vhadded_gross_subtotal',
  vhwithdrawn_chinese: 'vhwithdrawn_chinese',
  vhwithdrawn_japanese: 'vhwithdrawn_japanese',
  vhwithdrawn_korean: 'vhwithdrawn_korean',
  vhwithdrawn_noncjk: 'vhwithdrawn_noncjk',
  vhwithdrawn_subtotal: 'vhwithdrawn_subtotal',
  vh_film_chinese: 'vh_film_chinese',
  vh_film_japanese: 'vh_film_japanese',
  vh_film_korean: 'vh_film_korean',
  vh_film_subtotal: 'vh_film_subtotal',
  vh_fiche_chinese: 'vh_fiche_chinese',
  vh_fiche_japanese: 'vh_fiche_japanese',
  vh_fiche_korean: 'vh_fiche_korean',
  vh_fiche_subtotal: 'vh_fiche_subtotal',
  vh_film_fiche_chinese: 'vh_film_fiche_chinese',
  vh_film_fiche_japanese: 'vh_film_fiche_japanese',
  vh_film_fiche_korean: 'vh_film_fiche_korean',
  vh_film_fiche_subtotal: 'vh_film_fiche_subtotal',
  vhgrandtotal: 'vhgrandtotal',
  vhebooks_purchased_volume_total: 'vhebooks_purchased_volume_total',
  vhoverall_grand_total: 'vhoverall_grand_total',
  vhnotes: 'vhnotes',
  libraryyear: 'libraryyear'
} as const

export type Volume_HoldingsScalarFieldEnum = (typeof Volume_HoldingsScalarFieldEnum)[keyof typeof Volume_HoldingsScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  electronic?: Prisma.ElectronicOmit
  electronic_Books?: Prisma.Electronic_BooksOmit
  entry_Status?: Prisma.Entry_StatusOmit
  fiscal_Support?: Prisma.Fiscal_SupportOmit
  library?: Prisma.LibraryOmit
  libraryYear_ListAV?: Prisma.LibraryYear_ListAVOmit
  libraryYear_ListEBook?: Prisma.LibraryYear_ListEBookOmit
  libraryYear_ListEJournal?: Prisma.LibraryYear_ListEJournalOmit
  list_AV?: Prisma.List_AVOmit
  list_AV_Counts?: Prisma.List_AV_CountsOmit
  list_AV_Language?: Prisma.List_AV_LanguageOmit
  listCustomOtherHoldings?: Prisma.ListCustomOtherHoldingsOmit
  list_EBook?: Prisma.List_EBookOmit
  list_EBook_Counts?: Prisma.List_EBook_CountsOmit
  list_EBook_Language?: Prisma.List_EBook_LanguageOmit
  list_EJournal?: Prisma.List_EJournalOmit
  list_EJournal_Counts?: Prisma.List_EJournal_CountsOmit
  list_EJournal_Language?: Prisma.List_EJournal_LanguageOmit
  monographic_Acquisitions?: Prisma.Monographic_AcquisitionsOmit
  other_Holdings?: Prisma.Other_HoldingsOmit
  personnel_Support?: Prisma.Personnel_SupportOmit
  public_Services?: Prisma.Public_ServicesOmit
  exclude_Year?: Prisma.Exclude_YearOmit
  reflibrarytype?: Prisma.ReflibrarytypeOmit
  reflibraryregion?: Prisma.ReflibraryregionOmit
  language?: Prisma.LanguageOmit
  library_Year?: Prisma.Library_YearOmit
  user?: Prisma.UserOmit
  session?: Prisma.SessionOmit
  verificationToken?: Prisma.VerificationTokenOmit
  auditLog?: Prisma.AuditLogOmit
  user_Library?: Prisma.User_LibraryOmit
  role?: Prisma.RoleOmit
  users_Roles?: Prisma.Users_RolesOmit
  scheduledEvent?: Prisma.ScheduledEventOmit
  serials?: Prisma.SerialsOmit
  surveySession?: Prisma.SurveySessionOmit
  unprocessed_Backlog_Materials?: Prisma.Unprocessed_Backlog_MaterialsOmit
  volume_Holdings?: Prisma.Volume_HoldingsOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

