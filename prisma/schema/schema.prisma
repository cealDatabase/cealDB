generator client {
  provider = "prisma-client"
  output   = "../generated/client"
}

datasource db {
  provider = "postgresql"
}

model Exclude_Year {
  exyear Int @id
}

model Reflibrarytype {
  id          Int       @id @default(autoincrement())
  librarytype String
  library     Library[]
}

model Reflibraryregion {
  id            Int       @id @default(autoincrement())
  libraryregion String
  library       Library[]
}

model Language {
  id                     Int                      @id @default(autoincrement())
  short                  String
  full                   String
  List_AV_Language       List_AV_Language[]
  List_EBook_Language    List_EBook_Language[]
  List_EJournal_Language List_EJournal_Language[]
}

model Library_Year {
  id                            Int                            @id @default(autoincrement())
  library                       Int?
  is_open_for_editing           Boolean?                       @default(false)
  admin_notes                   String?
  year                          Int
  updated_at                    DateTime
  is_active                     Boolean?                       @default(true)
  opening_date                  DateTime?                      // Form opening date (default Oct 1)
  closing_date                  DateTime?                      // Form closing date (default Dec 1)
  fiscal_year_start             DateTime?                      // Fiscal year start (July 1, past year)
  fiscal_year_end               DateTime?                      // Fiscal year end (June 30, current year)
  publication_date              DateTime?                      // Publication date (February, next year)
  broadcast_sent                Boolean?                       @default(false) // Track if broadcast email has been sent
  Electronic                    Electronic?
  Electronic_Books              Electronic_Books?
  Entry_Status                  Entry_Status?
  Fiscal_Support                Fiscal_Support?
  LibraryYear_ListAV            LibraryYear_ListAV[]
  LibraryYear_ListEBook         LibraryYear_ListEBook[]
  LibraryYear_ListEJournal      LibraryYear_ListEJournal[]
  Library                       Library?                       @relation(fields: [library], references: [id])
  List_AV                       List_AV[]
  List_EBook                    List_EBook[]
  List_EJournal                 List_EJournal[]
  Monographic_Acquisitions      Monographic_Acquisitions?
  Other_Holdings                Other_Holdings?
  Personnel_Support             Personnel_Support?
  Public_Services               Public_Services?
  Serials                       Serials?
  Unprocessed_Backlog_Materials Unprocessed_Backlog_Materials?
  Volume_Holdings               Volume_Holdings?
}

model User {
  id                        Int            @id @default(autoincrement())
  username                  String         @unique  // Primary identifier
  password                  String?        // New Argon2id hash, null means needs reset
  firstname                 String?        // Keep for legacy compatibility
  lastname                  String?        // Keep for legacy compatibility
  isactive                  Boolean        @default(true)
  lastlogin_at              DateTime?
  requires_password_reset   Boolean?        @default(true)  // Force password reset on first login
  password_reset_token      String?        // Token for password reset emails
  password_reset_expires    DateTime?      // Expiration for reset token
  email_verified            Boolean?        @default(false) // Email confirmation status
  created_at                DateTime?       @default(now())
  updated_at                DateTime?       @default(now()) @updatedAt
  
  // Relations
  User_Library              User_Library[]
  User_Roles                Users_Roles[]
  AuditLog                  AuditLog[]
  Session                   Session[]
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model AuditLog {
  id             Int      @id @default(autoincrement())
  user_id        Int?     // Nullable for system operations or failed logins
  username       String?  // Store username for reference even if user_id is null
  action         String   // CREATE, UPDATE, DELETE, SIGNIN, SIGNOUT, etc.
  table_name     String?  // Which table was affected (null for auth operations)
  record_id      String?  // ID of the affected record (stored as string for flexibility)
  old_values     Json?    // Previous values before change
  new_values     Json?    // New values after change
  ip_address     String?  // Client IP address
  user_agent     String?  // Browser/client info
  timestamp      DateTime @default(now())
  success        Boolean  @default(true)
  error_message  String?  // Store error details if operation failed
  
  // Relation to User table
  User User? @relation(fields: [user_id], references: [id])
  
  @@index([user_id])
  @@index([action])
  @@index([table_name])
  @@index([timestamp])
}

model User_Library {
  user_id    Int
  library_id Int
  Library    Library @relation(fields: [library_id], references: [id])
  User       User    @relation(fields: [user_id], references: [id])

  @@unique([user_id, library_id])
}

model Role {
  id         Int           @id @default(autoincrement())
  role       String
  name       String
  User_Roles Users_Roles[]
}

model Users_Roles {
  user_id Int
  role_id Int
  Role    Role @relation(fields: [role_id], references: [id])
  User    User @relation(fields: [user_id], references: [id])

  @@unique([user_id, role_id])
}

// Scheduled events for granular queue management
model ScheduledEvent {
  id              Int       @id @default(autoincrement())
  event_type      String    // 'BROADCAST', 'FORM_OPENING', 'FORM_CLOSING'
  year            Int       // Academic year this event is for
  scheduled_date  DateTime  // When this event should occur (date only, ignore time)
  status          String    @default("pending") // 'pending', 'completed', 'cancelled'
  created_by      Int?      // Super admin who created this
  created_at      DateTime  @default(now())
  completed_at    DateTime? // When the event was executed
  cancelled_at    DateTime? // When the event was cancelled
  notes           String?   // Optional notes from admin
  
  @@index([year])
  @@index([event_type])
  @@index([scheduled_date])
  @@index([status])
}
